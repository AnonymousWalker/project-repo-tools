'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseUsfmOfBook = undefined;
exports.parseManifest = parseManifest;
exports.parseBiblePackage = parseBiblePackage;

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _pathExtra = require('path-extra');

var _pathExtra2 = _interopRequireDefault(_pathExtra);

var _usfmJs = require('usfm-js');

var _usfmJs2 = _interopRequireDefault(_usfmJs);

var _bible = require('../resources/bible');

var bible = _interopRequireWildcard(_bible);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _util = require('util');

var _biblesHelpers = require('./biblesHelpers');

var _resourcesHelpers = require('./resourcesHelpers');

var resourcesHelpers = _interopRequireWildcard(_resourcesHelpers);

var _errors = require('../resources/errors');

var errors = _interopRequireWildcard(_errors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @description - This function outputs chapter files from an input usfm file
 * @param {String} usfmPath - Path of the usfm file
 * @param {String} outputPath - Path to store the chapter json files as output
 */
var parseUsfmOfBook = exports.parseUsfmOfBook = function parseUsfmOfBook(usfmPath, outputPath) {
  var usfmData = _fsExtra2.default.readFileSync(usfmPath, 'UTF-8').toString();
  var converted = _usfmJs2.default.toJSON(usfmData, { convertToInt: ["occurrence", "occurrences"] });
  var chapters = converted.chapters;

  Object.keys(chapters).forEach(function (chapter) {
    _fsExtra2.default.outputFileSync(_pathExtra2.default.join(outputPath, chapter + '.json'), JSON.stringify(chapters[chapter], null, 2));
  });
};

/**
 * parses manifest.yaml data to create manifest.json
 * @param {String} extractedFilePath - path containing manifest.yaml
 * @param {string} outputPath - path to place manifest.json
 * @return {Object} new manifest data
 */

// constants

// helpers
/* eslint-disable camelcase */
/**
 * packageParseHelpers.js - methods for processing manifest and USFM files to verseObjects
 */

function parseManifest(extractedFilePath, outputPath) {
  var oldManifest = resourcesHelpers.getResourceManifest(extractedFilePath);
  return (0, _biblesHelpers.generateBibleManifest)(oldManifest, outputPath);
}

/**
 * Parse the bible package to generate json bible contents, manifest, and index
 * @param {{
 *          languageId: String,
 *          resourceId: String,
 *          localModifiedTime: String,
 *          remoteModifiedTime: String,
 *          downloadUrl: String,
 *          version: String,
 *          subject: String,
 *          catalogEntry: {langResource, bookResource, format}
 *        }} resource - resource entry for download
 * @param {String} sourcePath - path to unzipped files from bible package
 * @param {String} outputPath - path to store processed bible
 * @return {Boolean} true if success
 */
function parseBiblePackage(resource, sourcePath, outputPath) {
  var index = {};
  if (!resource || !(0, _util.isObject)(resource) || !resource.languageId || !resource.resourceId) throw Error(resourcesHelpers.formatError(resource, errors.RESOURCE_NOT_GIVEN));
  if (!sourcePath) throw Error(resourcesHelpers.formatError(resource, errors.SOURCE_PATH_NOT_GIVEN));
  if (!_fsExtra2.default.pathExistsSync(sourcePath)) throw Error(resourcesHelpers.formatError(resource, errors.SOURCE_PATH_NOT_EXIST + ": " + sourcePath));
  if (!outputPath) throw Error(resourcesHelpers.formatError(resource, errors.OUTPUT_PATH_NOT_GIVEN));
  try {
    var isOL = resource.resourceId === 'ugnt' || resource.resourceId === 'uhb';
    var manifest = parseManifest(sourcePath, outputPath);
    if (!manifest.projects) throw Error(resourcesHelpers.formatError(resource, errors.MANIFEST_MISSING_BOOKS));
    manifest.catalog_modified_time = resource.remoteModifiedTime;
    var savePath = _pathExtra2.default.join(outputPath, 'manifest.json');
    _fsExtra2.default.writeFileSync(savePath, JSON.stringify(manifest, null, 2));
    var projects = manifest.projects || [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = projects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var project = _step.value;

        if (project.identifier && project.path) {
          var identifier = project.identifier.toLowerCase();
          var bookPath = _pathExtra2.default.join(outputPath, identifier);
          parseUsfmOfBook(_pathExtra2.default.join(sourcePath, project.path), bookPath);
          indexBook(bookPath, index, identifier, isOL);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    saveIndex(outputPath, index);
  } catch (error) {
    throw Error(resourcesHelpers.formatError(resource, errors.ERROR_PARSING_BIBLE + ": " + error.message));
  }
  return true;
}

/**
 * get word count for verse - will also recursively check children
 * @param {Array} verseObjects - array to search for verseObjects
 * @return {number} word count found in verseObjects
 */
function getWordCount(verseObjects) {
  var wordCount = 0;
  if (verseObjects && verseObjects.length) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = verseObjects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var item = _step2.value;

        if (item.type === 'word') {
          wordCount++;
        } else if (item.children) {
          wordCount += getWordCount(item.children);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
  return wordCount;
}

/**
 * @description - update index with chapter/verse/words for specified book code
 * @param {string} bookPath - path to books
 * @param {Object} index - data for index.json
 * @param {string} bookCode - book to index
 * @param {Boolean} isOL - if true then this is an Original Language
 */
function indexBook(bookPath, index, bookCode, isOL) {
  var expectedChapters = bible.BOOK_CHAPTER_VERSES[bookCode];
  if (!expectedChapters) {
    throw new Error(errors.INVALID_BOOK_CODE + ": " + bookCode);
  }
  var files = _fsExtra2.default.readdirSync(bookPath);
  var chapterCount = Object.keys(expectedChapters).length;
  _assert2.default.deepEqual(files.length, chapterCount);
  var bookIndex = {};
  index[bookCode] = bookIndex;

  // add chapters
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = Object.keys(expectedChapters)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var chapter = _step3.value;

      var expectedVerseCount = parseInt(expectedChapters[chapter], 10);
      var chapterPath = _pathExtra2.default.join(bookPath, chapter + ".json");
      var ugntChapter = _fsExtra2.default.readJSONSync(chapterPath);
      var ugntVerses = Object.keys(ugntChapter);
      var frontPos = ugntVerses.indexOf("front");
      if (frontPos >= 0) {
        // remove chapter front matter
        ugntVerses.splice(frontPos, 1); // remove front item
      }
      if (ugntVerses.length !== expectedVerseCount) {
        console.warn('WARNING: ' + bookCode + ' - in chapter ' + chapter + ', found ' + ugntVerses.length + ' verses but should be ' + expectedVerseCount + ' verses');
      }

      if (isOL) {
        // if an OL, we need word counts of verses
        var chapterIndex = {};
        bookIndex[chapter] = chapterIndex;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = ugntVerses[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var verse = _step4.value;

            var words = ugntChapter[verse];
            if (words.verseObjects) {
              // check for new verse objects support
              words = words.verseObjects;
            }
            chapterIndex[verse] = getWordCount(words);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } else {
        (function () {
          // is not an OL, so we need verse count
          var highVerse = 0;
          Object.keys(ugntChapter).forEach(function (verseID) {
            var verse = parseInt(verseID);
            if (verse > highVerse) {
              // get highest verse
              highVerse = verse;
            }
          });
          bookIndex[chapter] = highVerse;
        })();
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (!isOL) {
    // is not an OL, so we add chapter count
    bookIndex.chapters = chapterCount;
  }
}

/**
 * @description save index to index.json
 * @param {String} outputFolder - where to put index.json
 * @param {Object} index - data for index.json
 */
function saveIndex(outputFolder, index) {
  var indexPath = _pathExtra2.default.join(outputFolder, 'index.json');
  if (_fsExtra2.default.existsSync(indexPath)) {
    var tempPath = indexPath + "_temp";
    _fsExtra2.default.moveSync(indexPath, tempPath);
    _fsExtra2.default.removeSync(tempPath);
  }
  var indexStr = JSON.stringify(index, null, 2);
  _fsExtra2.default.outputFileSync(indexPath, indexStr, 'UTF-8');
}