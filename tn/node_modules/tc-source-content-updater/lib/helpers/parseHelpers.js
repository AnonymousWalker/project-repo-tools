'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RESOURCE_ID_MAP = exports.TC_RESOURCES = undefined;
exports.getResourcesForLanguage = getResourcesForLanguage;
exports.getUpdatedLanguageList = getUpdatedLanguageList;
exports.getLatestResources = getLatestResources;
exports.getValidArray = getValidArray;
exports.getFormatsForResource = getFormatsForResource;
exports.parseCatalogResources = parseCatalogResources;
exports.formatResources = formatResources;

var _errors = require('../resources/errors');

var ERROR = _interopRequireWildcard(_errors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint-disable camelcase,no-empty,no-negated-condition */


var TC_RESOURCES = exports.TC_RESOURCES = ['Bible', 'Aligned_Bible', 'Greek_New_Testament', 'Translator_Notes', 'Bible_translation_comprehension_questions', 'Translation_Words', 'Translation_Academy'];
var RESOURCE_ID_MAP = exports.RESOURCE_ID_MAP = {
  translationWords: 'tw',
  translationNotes: 'tn',
  translationAcademy: 'ta'
};

/**
 * get all resources to update for language
 * @param {Array.<{
 *                   languageId: String,
 *                   resourceId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String,
 *                   downloadUrl: String,
 *                   version: String,
 *                   subject: String,
 *                   catalogEntry: {langResource, bookResource, format}
 *                 }>} resources - resources to filter
 * @param {String} languageId - language to search for
 * @return {Array.<{
 *                   languageId: String,
 *                   resourceId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String,
 *                   downloadUrl: String,
 *                   version: String,
 *                   subject: String,
 *                   catalogEntry: {langResource, bookResource, format}
 *                 }>|null} - filtered resources for language (returns null on error)
 */
function getResourcesForLanguage(resources, languageId) {
  if (!Array.isArray(resources)) {
    return null;
  }
  return resources.filter(function (resource) {
    return resource.languageId === languageId;
  });
}

/**
 * extract list of languages that need to be updated from resources
 *  that need to be updated
 *
 * @param {Array.<{
 *                   languageId: String,
 *                   resourceId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String,
 *                   downloadUrl: String,
 *                   version: String,
 *                   subject: String,
 *                   catalogEntry: {langResource, bookResource, format}
 *                 }>} updatedRemoteResources - resources that have been updated in remote catalog
 * @return {
 *          Array.<{
 *                   languageId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String
 *                 }>
 *         }|null} - list of languages that have updates in catalog (returns null on error)
 */
function getUpdatedLanguageList(updatedRemoteResources) {
  if (!Array.isArray(updatedRemoteResources)) {
    return null;
  }
  var updatedLanguages = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var resource = _step.value;

      var languageId = resource.languageId;
      var updatedBible = {
        languageId: languageId,
        localModifiedTime: resource.localModifiedTime || '',
        remoteModifiedTime: resource.remoteModifiedTime
      };
      var dup = updatedLanguages.findIndex(function (item) {
        return item.languageId === languageId;
      });
      if (dup < 0) {
        updatedLanguages.push(updatedBible); // add if language not present
      }
    };

    for (var _iterator = updatedRemoteResources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return updatedLanguages.sort(function (a, b) {
    return a.languageId > b.languageId ? 1 : -1;
  });
}

/**
 * Gets the list of all new resources in remoteCatalog, except for
 * the ones already up to date in the given list
 *
 * @param {{subjects: Array.<Object>}} catalog - to parse
 * @param {Array.<{
 *                  languageId: String,
 *                  resourceId: String,
 *                  modifiedTime: String,
 *                  }>} localResourceList - list of resources that are on the users local machine already {}
 * @return {Array.<{
 *                   languageId: String,
 *                   resourceId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String,
 *                   downloadUrl: String,
 *                   version: String,
 *                   subject: String,
 *                   catalogEntry: {subject, resource, format}
 *                 }>} updated resources  (throws exception on error)
 */
function getLatestResources(catalog, localResourceList) {
  if (!catalog || !Array.isArray(localResourceList)) {
    throw new Error(ERROR.PARAMETER_ERROR);
  }
  var tCoreResources = parseCatalogResources(catalog, true, TC_RESOURCES);
  // remove resources that are already up to date
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop2 = function _loop2() {
      var localResource = _step2.value;

      var resourceId = localResource.resourceId;
      if (localResource.languageId && resourceId) {
        resourceId = RESOURCE_ID_MAP[resourceId] || resourceId; // map resource names to ids
        var index = tCoreResources.findIndex(function (remoteResource) {
          return localResource.languageId === remoteResource.languageId && remoteResource.resourceId === resourceId;
        });
        if (index >= 0) {
          var catalogResource = tCoreResources[index];
          var isNewer = !localResource.modifiedTime || catalogResource.remoteModifiedTime > localResource.modifiedTime;
          if (!isNewer) {
            // if resource up to date, remove it from resource list
            tCoreResources.splice(index, 1);
          } else {
            catalogResource.localModifiedTime = localResource.modifiedTime;
          }
        }
      }
    };

    for (var _iterator2 = localResourceList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      _loop2();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return tCoreResources.sort(function (a, b) {
    return a.languageId > b.languageId ? 1 : -1;
  }); // resources that are already up to date have been removed, sort by language
}

/**
 * if Array is not valid, return empty array
 * @param {Array} array - array to validate
 * @return {Array} array if valid, or empty array
 */
function getValidArray(array) {
  if (Array.isArray(array)) {
    return array;
  }
  return [];
}

/**
 * gets an array of the formats.  Most are in resources.formats, but tWords are in resources.projects.formats
 * @param {Object} resource object
 * @return {Array} array if valid, or empty array
 */
function getFormatsForResource(resource) {
  if (Array.isArray(resource.formats)) {
    return resource.formats;
  }

  if (Array.isArray(resource.projects)) {
    var formats = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = resource.projects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var project = _step3.value;

        var projectFormats = getFormatsForResource(project);
        formats.push.apply(formats, _toConsumableArray(projectFormats));
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return formats;
  }

  return [];
}

/**
 * parses the remoteCatalog and returns list of catalog resources
 *
 * @param {{subjects: Array.<Object>}} catalog - to parse
 * @param {boolean} ignoreObsResources - if true then reject obs resources
 * @param {Array.<String>} subjectFilters - optional array of subjects to include.  If null then every subject is returned
 * @return {Array.<{
 *                   languageId: String,
 *                   resourceId: String,
 *                   remoteModifiedTime: String,
 *                   downloadUrl: String,
 *                   version: String,
 *                   subject: String,
 *                   catalogEntry: {subject, resource, format}
 *                 }>|null} list of updated resources (returns null on error)
 */
function parseCatalogResources(catalog) {
  var ignoreObsResources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var subjectFilters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!catalog || !Array.isArray(catalog.subjects)) {
    throw new Error(ERROR.CATALOG_CONTENT_ERROR);
  }
  var catalogResources = [];
  if (catalog && catalog.subjects) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = catalog.subjects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var catSubject = _step4.value;

        var subject = catSubject.identifier;
        var isGreekOL = catSubject.language === "el-x-koine";
        var _languageId = isGreekOL ? 'grc' : catSubject.language; // we use grc internally for Greek Original language
        var resources = getValidArray(catSubject.resources);
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = resources[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var resource = _step5.value;

            var isCheckingLevel2 = resource.checking.checking_level >= 2;
            var _resourceId = resource.identifier;
            if (ignoreObsResources && _resourceId.indexOf('obs') >= 0) {
              // see if we should skip obs resources
              continue;
            }
            var version = resource.version;
            var formats = getFormatsForResource(resource);
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = formats[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var format = _step6.value;

                try {
                  var isZipFormat = format.format.indexOf("application/zip;") >= 0;
                  var downloadUrl = format.url;
                  var remoteModifiedTime = format.modified;
                  var isDesiredSubject = !subjectFilters || subjectFilters.includes(subject);
                  if (isDesiredSubject && isZipFormat && isCheckingLevel2 && downloadUrl && remoteModifiedTime && _languageId && version) {
                    var foundResource = {
                      languageId: _languageId,
                      resourceId: _resourceId,
                      remoteModifiedTime: remoteModifiedTime,
                      downloadUrl: downloadUrl,
                      version: version,
                      subject: subject,
                      catalogEntry: {
                        subject: catSubject,
                        resource: resource,
                        format: format
                      }
                    };
                    catalogResources.push(foundResource);
                  }
                } catch (e) {
                  // recover if required fields are missing
                }
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  }
  return catalogResources;
}

/**
 * Formats the given content in an importable form for tC
 * @param {Object} content - The unparsed content from DCS
 */
function formatResources(content) {
  //
}