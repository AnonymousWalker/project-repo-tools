'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unzipResource = undefined;
exports.getVersionFromManifest = getVersionFromManifest;
exports.getResourceManifest = getResourceManifest;
exports.getResourceManifestFromJson = getResourceManifestFromJson;
exports.getResourceManifestFromYaml = getResourceManifestFromYaml;
exports.getVersionsInPath = getVersionsInPath;
exports.sortVersions = sortVersions;
exports.getLatestVersionInPath = getLatestVersionInPath;
exports.getSubdirOfUnzippedResource = getSubdirOfUnzippedResource;
exports.processResource = processResource;
exports.getActualResourcePath = getActualResourcePath;
exports.makeTwGroupDataResource = makeTwGroupDataResource;
exports.removeAllButLatestVersion = removeAllButLatestVersion;
exports.formatError = formatError;
exports.getErrorMessage = getErrorMessage;
exports.appendError = appendError;

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _pathExtra = require('path-extra');

var _pathExtra2 = _interopRequireDefault(_pathExtra);

var _yamljs = require('yamljs');

var _yamljs2 = _interopRequireDefault(_yamljs);

var _util = require('util');

var _zipFileHelpers = require('./zipFileHelpers');

var zipFileHelpers = _interopRequireWildcard(_zipFileHelpers);

var _twArticleHelpers = require('./translationHelps/twArticleHelpers');

var twArticleHelpers = _interopRequireWildcard(_twArticleHelpers);

var _taArticleHelpers = require('./translationHelps/taArticleHelpers');

var taArticleHelpers = _interopRequireWildcard(_taArticleHelpers);

var _twGroupDataHelpers = require('./translationHelps/twGroupDataHelpers');

var twGroupDataHelpers = _interopRequireWildcard(_twGroupDataHelpers);

var _packageParseHelpers = require('./packageParseHelpers');

var packageParseHelpers = _interopRequireWildcard(_packageParseHelpers);

var _errors = require('../resources/errors');

var errors = _interopRequireWildcard(_errors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint-disable no-console,max-len,camelcase */

// helpers

// constants


var translationHelps = {
  ta: 'translationAcademy',
  tn: 'translationNotes',
  tw: 'translationWords',
  tq: 'translationQuestions'
};

/**
 * @description - Gets the version from the manifest
 * @param {String} resourcePath - folder for manifest.json or yaml
 * @return {String} version
 */
function getVersionFromManifest(resourcePath) {
  var manifest = getResourceManifest(resourcePath);
  if (!manifest || !manifest.dublin_core || !manifest.dublin_core.version) {
    return null;
  }
  return manifest.dublin_core.version;
}

/**
 * @description Helper function to get manifest file from the resources folder. First
 * it will try manifest.json, then manifest.yaml.
 * @param {String} resourcePath - path to a resource folder which contains the manifest file in its root.
 * @return {Object} manifest
 */
function getResourceManifest(resourcePath) {
  var manifest = getResourceManifestFromJson(resourcePath);
  if (!manifest) {
    return getResourceManifestFromYaml(resourcePath);
  }
  return manifest;
}

/**
 * @description - Turns a manifest.json file into an object and returns it, null if doesn't exist
 * @param {String} resourcePath - folder for manifest.json
 * @return {Object} manifest
 */
function getResourceManifestFromJson(resourcePath) {
  var fileName = 'manifest.json';
  var manifestPath = _pathExtra2.default.join(resourcePath, fileName);
  var manifest = null;
  if (_fsExtra2.default.existsSync(manifestPath)) {
    manifest = _fsExtra2.default.readJsonSync(manifestPath);
  }
  return manifest;
}

/**
 * @description - Turns a manifest.yaml file into an object and returns it, null if doesn't exist
 * @param {String} resourcePath - folder for manifest.yaml
 * @return {Object} manifest
 */
function getResourceManifestFromYaml(resourcePath) {
  var fileName = 'manifest.yaml';
  var manifestPath = _pathExtra2.default.join(resourcePath, fileName);
  var manifest = null;
  if (_fsExtra2.default.existsSync(manifestPath)) {
    var yamlManifest = _fsExtra2.default.readFileSync(manifestPath, 'utf8').replace(/^\uFEFF/, '');
    manifest = _yamljs2.default.parse(yamlManifest);
  }
  return manifest;
}

/**
 * Returns an array of versions found in the path that start with [vV]\d
 * @param {String} resourcePath - base path to search for versions
 * @return {Array} - array of versions, e.g. ['v1', 'v10', 'v1.1']
 */
function getVersionsInPath(resourcePath) {
  if (!resourcePath || !_fsExtra2.default.pathExistsSync(resourcePath)) {
    return null;
  }
  var isVersionDirectory = function isVersionDirectory(name) {
    var fullPath = _pathExtra2.default.join(resourcePath, name);
    return _fsExtra2.default.lstatSync(fullPath).isDirectory() && name.match(/^v\d/i);
  };
  return sortVersions(_fsExtra2.default.readdirSync(resourcePath).filter(isVersionDirectory));
}

/**
 * Returns a sorted an array of versions so that numeric parts are properly ordered (e.g. v10a < v100)
 * @param {Array} versions - array of versions unsorted: ['v05.5.2', 'v5.5.1', 'V6.21.0', 'v4.22.0', 'v6.1.0', 'v6.1a.0', 'v5.1.0', 'V4.5.0']
 * @return {Array} - array of versions sorted:  ["V4.5.0", "v4.22.0", "v5.1.0", "v5.5.1", "v05.5.2", "v6.1.0", "v6.1a.0", "V6.21.0"]
 */
function sortVersions(versions) {
  // Don't sort if null, empty or not an array
  if (!versions || !Array.isArray(versions)) {
    return versions;
  }
  // Only sort of all items are strings
  for (var i = 0; i < versions.length; ++i) {
    if (typeof versions[i] !== 'string') {
      return versions;
    }
  }
  versions.sort(function (a, b) {
    return String(a).localeCompare(b, undefined, { numeric: true });
  });
  return versions;
}

/**
 * Return the full path to the highest version folder in resource path
 * @param {String} resourcePath - base path to search for versions
 * @return {String} - path to highest version
 */
function getLatestVersionInPath(resourcePath) {
  var versions = sortVersions(getVersionsInPath(resourcePath));
  if (versions && versions.length) {
    return _pathExtra2.default.join(resourcePath, versions[versions.length - 1]);
  }
  return null; // return illegal path
}

/**
 * @description Unzips a resource's zip file to an imports directory for processing
 * @param {Object} resource Resource object containing resourceId and languageId
 * @param {String} zipFilePath Path to the zip file
 * @param {string} resourcesPath Path to the resources directory
 * @return {String} Path to the resource's import directory
 */
var unzipResource = exports.unzipResource = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(resource, zipFilePath, resourcesPath) {
    var importsPath, importPath;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            importsPath = _pathExtra2.default.join(resourcesPath, 'imports');

            _fsExtra2.default.ensureDirSync(importsPath);
            importPath = zipFilePath.split('.').slice(0, -1).join('.');
            _context.next = 5;
            return zipFileHelpers.extractZipFile(zipFilePath, importPath);

          case 5:
            return _context.abrupt('return', importPath);

          case 6:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function unzipResource(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Gets the single subdirector of an extracted zip file path
 * @param {String} extractedFilesPath Extracted files path
 * @return {String} The subdir in the extracted path
 */
function getSubdirOfUnzippedResource(extractedFilesPath) {
  var subdirs = _fsExtra2.default.readdirSync(extractedFilesPath);
  if (subdirs.length === 1 && _fsExtra2.default.lstatSync(_pathExtra2.default.join(extractedFilesPath, subdirs[0])).isDirectory()) {
    return _pathExtra2.default.join(extractedFilesPath, subdirs[0]);
  }
  return extractedFilesPath;
}

/**
 * @description Processes a resource in the imports directory as needed
 * @param {Object} resource Resource object
 * @param {String} sourcePath Path the the source dictory of the resource
 * @return {String} Path to the directory of the processed files
 */
function processResource(resource, sourcePath) {
  if (!resource || !(0, _util.isObject)(resource) || !resource.languageId || !resource.resourceId) throw Error(formatError(resource, errors.RESOURCE_NOT_GIVEN));
  if (!sourcePath) throw Error(formatError(resource, errors.SOURCE_PATH_NOT_GIVEN));
  if (!_fsExtra2.default.pathExistsSync(sourcePath)) throw Error(formatError(resource, errors.SOURCE_PATH_NOT_EXIST));
  var processedFilesPath = sourcePath + '_processed';
  _fsExtra2.default.ensureDirSync(processedFilesPath);
  switch (resource.subject) {
    case 'Translation_Words':
      twArticleHelpers.processTranslationWords(resource, sourcePath, processedFilesPath);
      break;
    case 'Translation_Academy':
      taArticleHelpers.processTranslationAcademy(resource, sourcePath, processedFilesPath);
      break;
    case 'Bible':
    case 'Aligned_Bible':
    case 'Greek_New_Testament':
      packageParseHelpers.parseBiblePackage(resource, sourcePath, processedFilesPath);
      break;
    default:
      _fsExtra2.default.copySync(sourcePath, processedFilesPath);
  }
  var manifest = getResourceManifest(sourcePath);
  if (!getResourceManifest(processedFilesPath) && manifest) {
    manifest.catalog_modified_time = resource.remoteModifiedTime;
    _fsExtra2.default.writeFileSync(_pathExtra2.default.join(processedFilesPath, 'manifest.json'), JSON.stringify(manifest, null, 2));
  }
  return processedFilesPath;
}

/**
 * @description Gets the actual path to a resource based on the resource object
 * @param {Object} resource The resource object
 * @param {String} resourcesPath The path to the resources directory
 * @return {String} The resource path
 */
function getActualResourcePath(resource, resourcesPath) {
  var languageId = resource.languageId;
  var resourceName = resource.resourceId;
  var type = 'bibles';
  if (translationHelps[resourceName]) {
    resourceName = translationHelps[resourceName];
    type = 'translationHelps';
  }
  var actualResourcePath = _pathExtra2.default.join(resourcesPath, languageId, type, resourceName, 'v' + resource.version);
  _fsExtra2.default.ensureDirSync(actualResourcePath);
  return actualResourcePath;
}

/**
 * @description Downloads the resources that need to be updated for a given language using the DCS API
 * @param {Object.<{
 *             languageId: String,
 *             resourceId: String,
 *             localModifiedTime: String,
 *             remoteModifiedTime: String,
 *             downloadUrl: String,
 *             version: String,
 *             subject: String,
 *             catalogEntry: {langResource, bookResource, format}
 *           }>} resource - resource to download
 * @param {String} sourcePath Path to the Bible directory
 * @return {String} Path to the processed tw Group Data files
 */
function makeTwGroupDataResource(resource, sourcePath) {
  if (!resource) throw Error(formatError(resource, errors.RESOURCE_NOT_GIVEN));
  if (!_fsExtra2.default.pathExistsSync(sourcePath)) throw Error(formatError(resource, errors.SOURCE_PATH_NOT_EXIST));
  if (resource.languageId === 'grc' && resource.resourceId === 'ugnt' || resource.languageId === 'hbo' && resource.resourceId === 'uhb') {
    var twGroupDataPath = _pathExtra2.default.join(sourcePath + '_tw_group_data_' + resource.languageId + '_v' + resource.version);
    var result = twGroupDataHelpers.generateTwGroupDataFromAlignedBible(resource, sourcePath, twGroupDataPath);
    if (result) return twGroupDataPath;
  }
}

/**
 * Removes all version directories except the latest
 * @param {String} resourcePath Path to the reosurce dirctory that has subdirs of versions
 * @return {Boolean} True if versions were deleted, false if nothing was touched
 */
function removeAllButLatestVersion(resourcePath) {
  // Remove the previoius verison(s)
  var versionDirs = getVersionsInPath(resourcePath);
  if (versionDirs && versionDirs.length > 1) {
    var lastVersion = versionDirs[versionDirs.length - 1];
    versionDirs.forEach(function (versionDir) {
      if (versionDir !== lastVersion) {
        _fsExtra2.default.removeSync(_pathExtra2.default.join(resourcePath, versionDir));
      }
    });
    return true;
  }
  return false;
}

/**
 * @description Formats an error for all resources to have a standard format
 * @param {Object} resource Resource object
 * @param {String} errMessage Error message
 * @return {String} The formatted error message
 */
function formatError(resource, errMessage) {
  if (!resource || !(0, _util.isObject)(resource) || !resource.languageId || !resource.resourceId) {
    resource = {
      languageId: 'unknown',
      resourceId: 'unknown'
    };
  }
  return resource.languageId + '_' + resource.resourceId + ': ' + errMessage;
}

/**
 *  converts error to string
 * @param {Error|String} error - error to append
 * @return {string} concatenated message
 */
function getErrorMessage(error) {
  return error && error.message || error || "UNDEFINED";
}

/**
 * appends error message to string
 * @param {string} str - string to use as prefix
 * @param {Error|String} err - error to append
 * @return {string} concatenated message
 */
function appendError(str, err) {
  return str + ": " + getErrorMessage(err);
}