'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateTwGroupDataFromAlignedBible = undefined;

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _pathExtra = require('path-extra');

var _pathExtra2 = _interopRequireDefault(_pathExtra);

var _bible = require('../../resources/bible');

var bible = _interopRequireWildcard(_bible);

var _util = require('util');

var _resourcesHelpers = require('../resourcesHelpers');

var resourcesHelpers = _interopRequireWildcard(_resourcesHelpers);

var _errors = require('../../resources/errors');

var errors = _interopRequireWildcard(_errors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @description Generates the tW Group Data files from the given aligned Bible
 * @param {Objecd} resource Resource object
 * @param {String} sourcePath Path to the Bible with aligned data
 * @param {String} outputPath Path where the translationWords group data is to be placed WITHOUT version
 * @return {Boolean} true if success
 */

// helpers
var generateTwGroupDataFromAlignedBible = exports.generateTwGroupDataFromAlignedBible = function generateTwGroupDataFromAlignedBible(resource, sourcePath, outputPath) {
  if (!resource || !(0, _util.isObject)(resource) || !resource.languageId || !resource.resourceId) throw Error(resourcesHelpers.formatError(resource, errors.RESOURCE_NOT_GIVEN));
  if (!sourcePath) throw Error(resourcesHelpers.formatError(resource, errors.SOURCE_PATH_NOT_GIVEN));
  if (!_fsExtra2.default.pathExistsSync(sourcePath)) throw Error(resourcesHelpers.formatError(resource, errors.SOURCE_PATH_NOT_EXIST));
  if (!outputPath) throw Error(resourcesHelpers.formatError(resource, errors.OUTPUT_PATH_NOT_GIVEN));
  if (_fsExtra2.default.pathExistsSync(outputPath)) _fsExtra2.default.removeSync(outputPath);
  var version = resourcesHelpers.getVersionFromManifest(sourcePath);
  if (!version) {
    return false;
  }
  var books = bible.BIBLE_LIST_NT.slice(0);
  books.forEach(function (bookName) {
    convertBookVerseObjectsToTwData(sourcePath, outputPath, bookName);
  });
  return true;
};

/**
 * @description Gets verseObjects of a book and converts to a tW data object to save to file
 * @param {String} sourcePath Usually path to the UGNT
 * @param {String} outputPath The output path for tW files
 * @param {String} bookName Book in format, e.g. '41-MAT'
 */

// constants
function convertBookVerseObjectsToTwData(sourcePath, outputPath, bookName) {
  var bookId = getbookId(bookName);
  var twData = {};
  var bookDir = _pathExtra2.default.join(sourcePath, bookId);
  if (_fsExtra2.default.existsSync(bookDir)) {
    var chapters = Object.keys(bible.BOOK_CHAPTER_VERSES[bookId]).length;
    for (var chapter = 1; chapter <= chapters; chapter++) {
      var chapterFile = _pathExtra2.default.join(bookDir, chapter + '.json');
      if (_fsExtra2.default.existsSync(chapterFile)) {
        var json = JSON.parse(_fsExtra2.default.readFileSync(chapterFile));

        var _loop = function _loop(verse) {
          var groupData = [];
          json[verse].verseObjects.forEach(function (verseObject) {
            populateGroupDataFromVerseObject(groupData, verseObject);
          });
          populateTwDataFromGroupData(twData, groupData, bookId, chapter, verse);
        };

        for (var verse in json) {
          _loop(verse);
        }
      }
    }
    for (var category in twData) {
      for (var groupId in twData[category]) {
        var groupPath = _pathExtra2.default.join(outputPath, category, 'groups', bookId, groupId + '.json');
        _fsExtra2.default.outputFileSync(groupPath, JSON.stringify(twData[category][groupId], null, 2));
      }
    }
  }
}

/**
 * @description Populates the groupData array with this verseObject and returns its own groupData for milestones
 * @param {Object} groupData Group Data object
 * @param {Object} verseObject Verse object
 * @param {Boolean} isMilestone If true, all word objects will be added to the group data
 * @return {Object} Returns group data for this verse object
 */
function populateGroupDataFromVerseObject(groupData, verseObject) {
  var isMilestone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var myGroupData = {
    quote: [],
    strong: []
  };
  if (verseObject.type === 'milestone' || verseObject.type === 'word' && (verseObject.tw || isMilestone)) {
    if (verseObject.type === 'milestone') {
      if (verseObject.text) {
        myGroupData.text.push(verseObject.text);
      }
      verseObject.children.forEach(function (childVerseObject) {
        var childGroupData = populateGroupDataFromVerseObject(groupData, childVerseObject, true);
        if (childGroupData) {
          myGroupData.quote = myGroupData.quote.concat(childGroupData.quote);
          myGroupData.strong = myGroupData.strong.concat(childGroupData.strong);
        }
      });
    } else if (verseObject.type === 'word') {
      myGroupData.quote.push(verseObject.text);
      myGroupData.strong.push(verseObject.strong);
    }
    if (myGroupData.quote.length) {
      if (verseObject.tw) {
        var twLinkItems = verseObject.tw.split('/');
        var groupId = twLinkItems.pop();
        var category = twLinkItems.pop();
        if (!groupData[category]) {
          groupData[category] = {};
        }
        if (!groupData[category][groupId]) {
          groupData[category][groupId] = [];
        }
        groupData[category][groupId].push({
          quote: myGroupData.quote.join(' '),
          strong: myGroupData.strong
        });
      }
    }
  }
  return myGroupData;
}

/**
 * @description Takes what is in the groupData array and populates the tWData
 * @param {Object} twData Data to be collected for tw
 * @param {Object} groupData Group data object
 * @param {String} bookId Three character code for the book
 * @param {int} chapter Number of the chapter
 * @param {int} verse Number of the verse
 */
function populateTwDataFromGroupData(twData, groupData, bookId, chapter, verse) {
  var _loop2 = function _loop2(category) {
    if (!twData[category]) {
      twData[category] = [];
    }

    var _loop3 = function _loop3(groupId) {
      if (!twData[category][groupId]) {
        twData[category][groupId] = [];
      }
      var occurrences = {};
      groupData[category][groupId].forEach(function (item) {
        if (!occurrences[item.quote]) {
          occurrences[item.quote] = 1;
        }
        twData[category][groupId].push({
          priority: 1,
          comments: false,
          reminders: false,
          selections: false,
          verseEdits: false,
          contextId: {
            reference: {
              bookId: bookId,
              chapter: chapter,
              verse: parseInt(verse)
            },
            tool: 'translationWords',
            groupId: groupId,
            quote: item.quote,
            strong: item.strong,
            occurrence: occurrences[item.quote]++
          }
        });
      });
    };

    for (var groupId in groupData[category]) {
      _loop3(groupId);
    }
  };

  for (var category in groupData) {
    _loop2(category);
  }
}

/**
 * @description Splits book code out of book name, for example 'mat' from '41-MAT'
 * @param {String} bookName Book in format '41-MAT'
 * @return {String} The book ID, e.g. 'mat'
 */
function getbookId(bookName) {
  return bookName.split('-')[1].toLowerCase();
}