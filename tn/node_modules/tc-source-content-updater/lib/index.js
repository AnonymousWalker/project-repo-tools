'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourcesForLanguage = getResourcesForLanguage;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ospath = require('ospath');

var _ospath2 = _interopRequireDefault(_ospath);

var _apiHelpers = require('./helpers/apiHelpers');

var apiHelpers = _interopRequireWildcard(_apiHelpers);

var _parseHelpers = require('./helpers/parseHelpers');

var parseHelpers = _interopRequireWildcard(_parseHelpers);

var _moveResourcesHelpers = require('./helpers/moveResourcesHelpers');

var moveResourcesHelpers = _interopRequireWildcard(_moveResourcesHelpers);

var _packageParseHelpers = require('./helpers/packageParseHelpers');

var packageParseHelpers = _interopRequireWildcard(_packageParseHelpers);

var _taArticleHelpers = require('./helpers/translationHelps/taArticleHelpers');

var taArticleHelpers = _interopRequireWildcard(_taArticleHelpers);

var _twArticleHelpers = require('./helpers/translationHelps/twArticleHelpers');

var twArticleHelpers = _interopRequireWildcard(_twArticleHelpers);

var _twGroupDataHelpers = require('./helpers/translationHelps/twGroupDataHelpers');

var twGroupDataHelpers = _interopRequireWildcard(_twGroupDataHelpers);

var _resourcesDownloadHelpers = require('./helpers/resourcesDownloadHelpers');

var resourcesDownloadHelpers = _interopRequireWildcard(_resourcesDownloadHelpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
// helpers


/**
 * Updater constructor
 */
function Updater() {
  this.remoteCatalog = null;
  this.updatedCatalogResources = null;
}

Updater.prototype = {};

/**
 * Method to manually fetch the latest remoteCatalog for the current
 * Updater instance. This function has no return value
 */
Updater.prototype.updateCatalog = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return apiHelpers.getCatalog();

        case 2:
          this.remoteCatalog = _context.sent;

        case 3:
        case 'end':
          return _context.stop();
      }
    }
  }, _callee, this);
}));

/**
 * Used to initiate a load of the latest resource so that the user can then select which ones
 * they would like to update.
 * Note: This function only returns the resources that are not up to date on the user machine
 * before the request
 * @param {Array.<{
 *                  languageId: String,
 *                  resourceId: String,
 *                  modifiedTime: String,
 *                  }>} localResourceList - list of resources that are on the users local machine already {}
 * @return {
 *          Array.<{
 *                   languageId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String
 *                 }>
 *         }} - list of languages that have updates in catalog (throws exception on error)
 */
Updater.prototype.getLatestResources = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(localResourceList) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.updateCatalog();

          case 2:
            this.updatedCatalogResources = parseHelpers.getLatestResources(this.remoteCatalog, localResourceList);
            return _context2.abrupt('return', parseHelpers.getUpdatedLanguageList(this.updatedCatalogResources));

          case 4:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * get all resources to update for language
 * @param {String} languageId - language to search for
 * @return {Array.<{
 *                   languageId: String,
 *                   resourceId: String,
 *                   localModifiedTime: String,
 *                   remoteModifiedTime: String,
 *                   downloadUrl: String,
 *                   version: String,
 *                   subject: String,
 *                   catalogEntry: {langResource, bookResource, format}
 *                 }>} - all updated resources for language
 */
function getResourcesForLanguage(languageId) {
  return parseHelpers.getResourcesForLanguage(this.updatedCatalogResources, languageId);
}

/**
 * @description Downloads the resources that need to be updated for the given languages using the DCS API
 * @param {Array.<String>} languageList - Array of language codes to download the resources fsor
 * @param {String} resourcesPath - Path to the resources directory where each resource will be placed
 * @param {Array.<Object>} resources - Array of resources that are newer than previously downloaded resources;
 * defaults to this.updatedCatalogResources which was set by previously calling getLatestResources();
 * If getLatestResources() was never called or resources = null, function will get all resources for the given language(s)
 * (the latter is useful for getting all resources for a set of languages, such as including all resources of
 * 'en' and 'hi' in a build)
 * @return {Promise} Promise that resolves to return all the resources updated or rejects if a resource failed to download
 */
Updater.prototype.downloadResources = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(languageList, resourcesPath) {
    var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.updatedCatalogResources;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (resources) {
              _context3.next = 4;
              break;
            }

            _context3.next = 3;
            return this.getLatestResources([]);

          case 3:
            resources = this.updatedCatalogResources;

          case 4:
            return _context3.abrupt('return', resourcesDownloadHelpers.downloadResources(languageList, resourcesPath, resources));

          case 5:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function (_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();

/**
 * @description move the converted resource to user's resource folder
 * @param {String} resourceSourcePath - Location of selected downloaded resources
 * @param {String} languageCode - language of resource like en or hi
 * @return {Promise} Promise to move directory
 */
Updater.prototype.moveResources = function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(resourceSourcePath, languageCode) {
    var resourceTargetPath;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            resourceTargetPath = _path2.default.join(_ospath2.default.home(), 'translationCore', 'resources', languageCode);
            return _context4.abrupt('return', moveResourcesHelpers.move(resourceSourcePath, resourceTargetPath));

          case 2:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function (_x5, _x6) {
    return _ref4.apply(this, arguments);
  };
}();

/**
 * @description Parses the bible package to generate json bible contents, manifest, and index
 * @param {{
 *          languageId: String,
 *          resourceId: String,
 *          localModifiedTime: String,
 *          remoteModifiedTime: String,
 *          downloadUrl: String,
 *          version: String,
 *          subject: String,
 *          catalogEntry: {langResource, bookResource, format}
 *        }} resourceEntry - resource entry for download
 * @param {String} extractedFilesPath - path to unzipped files from bible package
 * @param {String} resultsPath - path to store processed bible
 * @return {Boolean} true if success
 */
Updater.prototype.parseBiblePackage = function (resourceEntry, extractedFilesPath, resultsPath) {
  return packageParseHelpers.parseBiblePackage(resourceEntry, extractedFilesPath, resultsPath);
};

/**
 * @description Processes the extracted files for translationAcademy to create a single file for each
 * article
 * @param {String} extractedFilesPath - Path to the extracted files that came from the zip file in the catalog
 * @param {String} outputPath - Path to place the processed files WITHOUT version in the path
 * @return {String} The path to the processed translationAcademy files with version
 */
Updater.prototype.processTranslationAcademy = function (extractedFilesPath, outputPath) {
  return taArticleHelpers.processTranslationAcademy(extractedFilesPath, outputPath);
};

/**
 * @description Processes the extracted files for translationWord to cerate the folder
 * structure and produce the index.js file for the language with the title of each article.
 * @param {String} extractedFilesPath - Path to the extracted files that came from the zip file from the catalog
 * @param {String} outputPath - Path to place the processed resource files WIHTOUT the version in the path
 * @return {String} Path to the processed translationWords files with version
 */
Updater.prototype.processTranslationWords = function (extractedFilesPath, outputPath) {
  return twArticleHelpers.processTranslationWords(extractedFilesPath, outputPath);
};

/**
 * @description Generates the tW Group Data files from the given aligned Bible
 * @param {string} biblePath Path to the Bible with aligned data
 * @param {string} outputPath Path where the translationWords group data is to be placed WITHOUT version
 * @return {string} Path where tW was generated with version
 */
Updater.prototype.generateTwGroupDataFromAlignedBible = function (biblePath, outputPath) {
  return twGroupDataHelpers.generateTwGroupDataFromAlignedBible(biblePath, outputPath);
};

exports.default = Updater;